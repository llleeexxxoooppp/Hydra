"""Module responsible for heightmap operators."""

import bpy, bpy.types
from bpy.props import StringProperty, BoolProperty

from Hydra import common
from Hydra.sim import heightmap
from Hydra.utils import nav, texture, apply
from Hydra.addon import ops_common

#-------------------------------------------- Preview

class PreviewOp(ops_common.HydraOperator):
	"""Heightmap modifier preview operator."""
	bl_idname = "hydra.hm_preview"
	bl_label = "Preview"
	bl_description = "Preview map"

	def invoke(self, ctx, event):
		target = self.get_target(ctx)
		hyd = target.hydra_erosion

		data = common.data
		if data.has_map(hyd.map_result):
			apply.add_preview(target)
		
		return {'FINISHED'}
	
class RemovePreviewOp(ops_common.HydraOperator):
	"""Heightmap modifier preview removal operator."""
	bl_idname = "hydra.hm_remove_preview"
	bl_label = "Remove preview"
	bl_description = "Remove preview modifier"
	bl_options = {'REGISTER'}

	def invoke(self, ctx, event):
		apply.remove_preview()
		return {'FINISHED'}

#-------------------------------------------- Merge

class MergeOp(ops_common.HydraOperator):
	"""Modifier apply to mesh operator."""
	bl_idname = "hydra.hm_merge"
	bl_label = "Apply Hydra modifier and all modifiers above it?"
	bl_description = "Applies the preview or modifier directly to the mesh. Also applies all visible modifiers up to it"
	bl_options = {'REGISTER'}

	@classmethod
	def poll(cls, ctx):
		ret = not ctx.object.data.shape_keys or len(ctx.object.data.shape_keys.key_blocks) == 0
		# has to be visible and generated by Hydra
		return ret and any(m for m in ctx.object.modifiers if m.show_viewport and (m.name.startswith("HYD_") or m.name.startswith("HYDP_")))

	def execute(self, ctx):
		hydra_mods = [m for m in ctx.object.modifiers if m.name.startswith("HYD_") or m.name.startswith("HYDP_")]

		for mod in ctx.object.modifiers:
			name = mod.name

			if mod.show_viewport:
				bpy.ops.object.modifier_apply(modifier=mod.name)
				if name.startswith("HYD_") or name.startswith("HYDP_"):
					break
		
		for mod in hydra_mods:
			if mod.name in ctx.object.modifiers:
				ctx.object.modifiers.remove(mod)

		apply.remove_preview()
		heightmap.set_result_as_source(ctx.object, as_base=True)
		nav.goto_modifier()
		return {'FINISHED'}

	def invoke(self, ctx, event):
		return ctx.window_manager.invoke_confirm(self, event)

class MergeShapeOp(ops_common.HydraOperator):
	"""Modifier apply as shape key operator."""
	bl_idname = "hydra.hm_merge_shape"
	bl_label = "Apply as shape"
	bl_description = "Applies the preview or modifier as a shape key"
	bl_options = {'REGISTER'}

	@classmethod
	def poll(cls, ctx):
		target = cls.get_target(ctx)
		m = next((m for m in target.modifiers if m.name.startswith("HYD_")), None)
		return m and m.type == "DISPLACE"

	def invoke(self, ctx, event):
		hyd = next((x for x in ctx.object.modifiers if x.name.startswith("HYD_")), None)
		if hyd:
			name = hyd.name
			keys = ctx.object.data.shape_keys
			shapeName = "HYD_Shape"
			if keys and shapeName in keys.key_blocks:
				ctx.object.shape_key_remove(keys.key_blocks[shapeName])

			bpy.ops.object.modifier_apply_as_shapekey(modifier=name)
			shape = ctx.object.data.shape_keys.key_blocks[name]
			shape.name = shapeName
			shape.value = 1

		apply.remove_preview()
		name = f"HYD_{ctx.object.name}_Guide"
		if name in bpy.data.objects:
			bpy.data.objects.remove(bpy.data.objects[name])
		heightmap.set_result_as_source(ctx.object)
		nav.goto_shape()
		return {'FINISHED'}

#-------------------------------------------- Move

class MoveOp(ops_common.HydraOperator):
	"""Apply Result as Source operator."""
	bl_idname = "hydra.hm_move"; bl_label = "Set as Source"
	bl_description = "Sets the Result heightmap as the new Source map"; bl_options = {'REGISTER'}

	def invoke(self, ctx, event):
		heightmap.set_result_as_source(self.get_target(ctx))
		return {'FINISHED'}

class MoveBackOp(ops_common.HydraOperator):
	"""Apply Source as Result operator."""
	bl_idname = "hydra.hm_move_back"; bl_label = "Set as Result"
	bl_description = "Sets this Source as the Result map and previews it"; bl_options = {'REGISTER'}

	def invoke(self, ctx, event):
		target = self.get_target(ctx)
		hyd = target.hydra_erosion
		data = common.data

		if hyd.map_result != hyd.map_source:
			data.try_release_map(hyd.map_result)
			
		src = data.get_map(hyd.map_source)

		txt = texture.clone(src.texture)
		hmid = data.create_map(src.name, txt, base=src)
		hyd.map_result = hmid

		apply.add_preview(target)
		return {'FINISHED'}

#-------------------------------------------- Delete

class DeleteOp(ops_common.HydraOperator):
	"""Delete Result operator."""
	bl_idname = "hydra.hm_delete"
	bl_label = "Delete this layer?"
	bl_description = "Deletes the generated heightmap"

	def execute(self, ctx):
		target = self.get_target(ctx)
		hyd = target.hydra_erosion

		apply.remove_preview()

		common.data.try_release_map(hyd.map_result)
		hyd.map_result = ""
		return {'FINISHED'}
	
	def invoke(self, ctx, event):
		return ctx.window_manager.invoke_confirm(self, event)

class ClearOp(ops_common.HydraOperator):
	"""Clear object textures operator."""
	bl_idname = "hydra.hm_clear"
	bl_label = "Delete cached heightmaps for this object?"
	bl_description = "Deletes all cached heightmaps for this object"

	def execute(self, ctx):
		target = self.get_target(ctx)
		hyd = target.hydra_erosion

		apply.remove_preview()

		common.data.try_release_map(hyd.map_base)
		common.data.try_release_map(hyd.map_source)
		common.data.try_release_map(hyd.map_result)

		hyd.map_base = ""
		hyd.map_source = ""
		hyd.map_result = ""
		self.report({'INFO'}, f"Successfuly cleared textures from: {target.name}")
		return {'FINISHED'}

	def invoke(self, ctx, event):
		return ctx.window_manager.invoke_confirm(self, event)

#-------------------------------------------- Apply

class ModifierOp(ops_common.HydraOperator):
	"""Apply as modifier operator."""
	bl_idname = "hydra.hm_apply_mod"
	bl_label = "As Displacement Modifier"
	bl_description = "Apply texture as a displacement modifier"

	@classmethod
	def poll(cls, ctx):
		target = cls.get_target(ctx)
		return target.hydra_erosion.tiling != "planet"

	def invoke(self, ctx, event):
		target = self.get_target(ctx)

		apply.remove_preview()
		displacement = heightmap.get_displacement(target, name=f"HYD_{target.name}_DISPLACE")
		apply.add_modifier(ctx.object, displacement)

		nav.goto_modifier()
		self.report({'INFO'}, f"Successfuly applied map as a displacement modifier")
		return {'FINISHED'}
	
class GeometryOp(ops_common.HydraOperator):
	"""Apply as modifier operator."""
	bl_idname = "hydra.hm_apply_geo"
	bl_label = "As Geometry Modifier"
	bl_description = "Apply texture as a Geometry Nodes modifier"

	def invoke(self, ctx, event):
		target = self.get_target(ctx)
		apply.remove_preview()
		displacement = heightmap.get_displacement(target, name=f"HYD_{target.name}_DISPLACE")

		apply.add_geometry_nodes(ctx.object, displacement)

		nav.goto_modifier()
		nav.goto_geometry(target)
		common.data.report(self, callerName="Erosion")
		return {'FINISHED'}

class DisplaceOp(ops_common.HydraOperator):
	"""Apply as displacement map operator."""
	bl_idname = "hydra.hm_apply_disp"
	bl_label = "As Displacement"
	bl_description = "Apply texture as a displacement node in the object's shader"

	def invoke(self, ctx, event):
		target = self.get_target(ctx)
		apply.remove_preview()
		displacement = heightmap.get_displacement(target, name=f"HYD_{target.name}_DISPLACE")

		apply.add_displacement(target, displacement)

		nav.goto_shader(target)
		self.report({'INFO'}, f"Successfuly applied map as a displacement")
		return {'FINISHED'}

class BumpOp(ops_common.HydraOperator):
	"""Apply as bump map operator."""
	bl_idname = "hydra.hm_apply_bump"
	bl_label = "As Bump"
	bl_description = "Apply texture as a bumpmap node in the object's shader"

	def invoke(self, ctx, event):
		target = self.get_target(ctx)
		apply.remove_preview()
		displacement = heightmap.get_displacement(target, name=f"HYD_{target.name}_DISPLACE")

		apply.add_bump(target, displacement)

		nav.goto_shader(target)
		self.report({'INFO'}, f"Successfuly applied map as a bumpmap")
		return {'FINISHED'}

class ImageOp(ops_common.HydraOperator):
	"""Export as image operator."""
	bl_idname = "hydra.hm_apply_img"
	bl_label = "As Image"
	bl_description = "Save heightmap to a Blender Image"

	save_target: StringProperty(default="")
	"""Heightmap ID."""
	name: StringProperty(default="")
	"""Created image name."""

	def invoke(self, ctx, event):
		data = common.data
		hm = data.get_map(self.save_target)
		img, _ = texture.write_image(self.name, hm.texture, exp_convert=hm.logarithmic)
		nav.goto_image(img)
		self.report({'INFO'}, f"Created texture: {self.name}")
		return {'FINISHED'}

#-------------------------------------------- Reload

class ReloadOp(ops_common.HydraOperator):
	"""Reload base map as source operator."""
	bl_idname = "hydra.hm_reload"
	bl_label = "Reload"
	bl_description = "Load original mesh heightmap as a source"

	def invoke(self, ctx, event):
		target = self.get_target(ctx)
		hyd = target.hydra_erosion
		data = common.data

		data.try_release_map(hyd.map_source)

		base = data.get_map(hyd.map_base)
		txt = texture.clone(base.texture)

		hyd.map_source = data.create_map(base.name, txt, base=base)

		self.report({'INFO'}, "Reloaded base map.")
		return {'FINISHED'}
	
class ForceReloadOp(ops_common.HydraOperator):
	"""Recalculate base and source maps operator."""
	bl_idname = "hydra.hm_force_reload"
	bl_label = "Recalculate source heightmap from object"
	bl_description = "Create a base heightmap from the current object"

	def execute(self, ctx):
		target = self.get_target(ctx)
		hyd = target.hydra_erosion

		common.data.try_release_map(hyd.map_base)
		common.data.try_release_map(hyd.map_source)

		heightmap.prepare_heightmap(target)

		self.report({'INFO'}, f"Recalculated base map.")
		return {'FINISHED'}
	
	def invoke(self, ctx, event):
		return ctx.window_manager.invoke_confirm(self, event)

#-------------------------------------------- Goto

class NavToImgOp(ops_common.HydraOperator):
	"""Navigate to entity operator."""
	bl_idname = "hydra.nav_img"
	bl_label = "View"
	bl_description = "View this image"

	target: StringProperty(default="")
	"""Target name."""

	def invoke(self, ctx, event):
		if self.target in bpy.data.images:
			nav.goto_image(bpy.data.images[self.target])
		else:
			self.report({'ERROR'}, f"Failed to find image.")
		return {'FINISHED'}
	
class NavToObjOp(ops_common.HydraOperator):
	"""Navigate to object operator."""
	bl_idname = "hydra.nav_obj"
	bl_label = "View"
	bl_description = "View this object"

	target: StringProperty(default="")
	"""Target name."""

	def invoke(self, ctx, event):
		if self.target in bpy.data.objects:
			nav.goto_object(bpy.data.objects[self.target])
		else:
			self.report({'ERROR'}, f"Failed to find image.")
		return {'FINISHED'}

#-------------------------------------------- Recovery

class RecoverOp(ops_common.HydraOperator):
	"""Recover heightmap data from previous session."""
	bl_idname = "hydra.hm_recover"
	bl_label = "Recover"
	bl_description = "Try to recover heightmap data from previous session"

	def invoke(self, ctx, event):
		heightmap.recover_heightmaps(self.get_target(ctx))
		common.data.report(self)
		return {"FINISHED"}

#-------------------------------------------- Exports

def get_exports()->list:
	return [
		ClearOp,
		MergeOp,
		MergeShapeOp,
		PreviewOp,
		RemovePreviewOp,
		MoveOp,
		MoveBackOp,
		DeleteOp,
		ModifierOp,
		GeometryOp,
		ImageOp,
		DisplaceOp,
		BumpOp,
		ReloadOp,
		ForceReloadOp,
		NavToImgOp,
		NavToObjOp,
		RecoverOp,
	]
